/* tslint:disable */
/* eslint-disable */
/**
 * FastAPI
 * No description provided (generated by Openapi Generator https://github.com/openapitools/openapi-generator)
 *
 * The version of the OpenAPI document: 0.1.0
 * 
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */


import globalAxios, { AxiosPromise, AxiosInstance, AxiosRequestConfig } from 'axios';
import { Configuration } from '../configuration';
// URLSearchParams not necessarily used
// @ts-ignore
import { URL, URLSearchParams } from 'url';
// Some imports not used depending on template conditions
// @ts-ignore
import { DUMMY_BASE_URL, assertParamExists, setApiKeyToObject, setBasicAuthToObject, setBearerAuthToObject, setOAuthToObject, setSearchParams, serializeDataIfNeeded, toPathString, createRequestFunction } from '../common';
// @ts-ignore
import { BASE_PATH, COLLECTION_FORMATS, RequestArgs, BaseAPI, RequiredError } from '../base';
// @ts-ignore
import { CatalogConfiguration } from '../models';
// @ts-ignore
import { CategoriesByIdRequest } from '../models';
// @ts-ignore
import { CategoriesRequest } from '../models';
// @ts-ignore
import { CategoriesResponse } from '../models';
// @ts-ignore
import { HTTPValidationError } from '../models';
// @ts-ignore
import { PartialConfiguration } from '../models';
// @ts-ignore
import { Product } from '../models';
// @ts-ignore
import { ProductsByIdRequest } from '../models';
// @ts-ignore
import { ProductsRequest } from '../models';
// @ts-ignore
import { ProductsResponse } from '../models';
// @ts-ignore
import { VendorsByIdRequest } from '../models';
// @ts-ignore
import { VendorsRequest } from '../models';
// @ts-ignore
import { VendorsResponse } from '../models';
/**
 * CatalogSearchServiceApi - axios parameter creator
 * @export
 */
export const CatalogSearchServiceApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @summary Create Configuration
         * @param {string} marketplaceId 
         * @param {PartialConfiguration} partialConfiguration 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createConfigurationCatalogSearchServiceConfigurationMarketplaceIdPost: async (marketplaceId: string, partialConfiguration: PartialConfiguration, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'marketplaceId' is not null or undefined
            assertParamExists('createConfigurationCatalogSearchServiceConfigurationMarketplaceIdPost', 'marketplaceId', marketplaceId)
            // verify required parameter 'partialConfiguration' is not null or undefined
            assertParamExists('createConfigurationCatalogSearchServiceConfigurationMarketplaceIdPost', 'partialConfiguration', partialConfiguration)
            const localVarPath = `/catalog-search-service/configuration/{marketplace_id}`
                .replace(`{${"marketplace_id"}}`, encodeURIComponent(String(marketplaceId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication HTTPBearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(partialConfiguration, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Create Indices
         * @param {string} marketplaceId 
         * @param {string} [suffix] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createIndicesCatalogSearchServiceConfigurationIndicesMarketplaceIdPost: async (marketplaceId: string, suffix?: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'marketplaceId' is not null or undefined
            assertParamExists('createIndicesCatalogSearchServiceConfigurationIndicesMarketplaceIdPost', 'marketplaceId', marketplaceId)
            const localVarPath = `/catalog-search-service/configuration/indices/{marketplace_id}`
                .replace(`{${"marketplace_id"}}`, encodeURIComponent(String(marketplaceId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication HTTPBearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            if (suffix !== undefined) {
                localVarQueryParameter['suffix'] = suffix;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Delete categories by ID.
         * @summary Delete Categories
         * @param {string} marketplaceId 
         * @param {CategoriesByIdRequest} categoriesByIdRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteCategories: async (marketplaceId: string, categoriesByIdRequest: CategoriesByIdRequest, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'marketplaceId' is not null or undefined
            assertParamExists('deleteCategories', 'marketplaceId', marketplaceId)
            // verify required parameter 'categoriesByIdRequest' is not null or undefined
            assertParamExists('deleteCategories', 'categoriesByIdRequest', categoriesByIdRequest)
            const localVarPath = `/catalog-search-service/catalogs/categories`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication HTTPBearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            if (marketplaceId !== undefined) {
                localVarQueryParameter['marketplaceId'] = marketplaceId;
            }


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(categoriesByIdRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Delete Configuration
         * @param {string} marketplaceId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteConfigurationCatalogSearchServiceConfigurationMarketplaceIdDelete: async (marketplaceId: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'marketplaceId' is not null or undefined
            assertParamExists('deleteConfigurationCatalogSearchServiceConfigurationMarketplaceIdDelete', 'marketplaceId', marketplaceId)
            const localVarPath = `/catalog-search-service/configuration/{marketplace_id}`
                .replace(`{${"marketplace_id"}}`, encodeURIComponent(String(marketplaceId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication HTTPBearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Delete Indices
         * @param {string} marketplaceId 
         * @param {string} [suffix] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteIndicesCatalogSearchServiceConfigurationIndicesMarketplaceIdDelete: async (marketplaceId: string, suffix?: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'marketplaceId' is not null or undefined
            assertParamExists('deleteIndicesCatalogSearchServiceConfigurationIndicesMarketplaceIdDelete', 'marketplaceId', marketplaceId)
            const localVarPath = `/catalog-search-service/configuration/indices/{marketplace_id}`
                .replace(`{${"marketplace_id"}}`, encodeURIComponent(String(marketplaceId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication HTTPBearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            if (suffix !== undefined) {
                localVarQueryParameter['suffix'] = suffix;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Delete products by ID.
         * @summary Delete Products
         * @param {string} marketplaceId 
         * @param {ProductsByIdRequest} productsByIdRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteProducts: async (marketplaceId: string, productsByIdRequest: ProductsByIdRequest, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'marketplaceId' is not null or undefined
            assertParamExists('deleteProducts', 'marketplaceId', marketplaceId)
            // verify required parameter 'productsByIdRequest' is not null or undefined
            assertParamExists('deleteProducts', 'productsByIdRequest', productsByIdRequest)
            const localVarPath = `/catalog-search-service/catalogs/products`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication HTTPBearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            if (marketplaceId !== undefined) {
                localVarQueryParameter['marketplaceId'] = marketplaceId;
            }


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(productsByIdRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Delete vendors by ID.
         * @summary Delete Vendors
         * @param {string} marketplaceId 
         * @param {VendorsByIdRequest} vendorsByIdRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteVendors: async (marketplaceId: string, vendorsByIdRequest: VendorsByIdRequest, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'marketplaceId' is not null or undefined
            assertParamExists('deleteVendors', 'marketplaceId', marketplaceId)
            // verify required parameter 'vendorsByIdRequest' is not null or undefined
            assertParamExists('deleteVendors', 'vendorsByIdRequest', vendorsByIdRequest)
            const localVarPath = `/catalog-search-service/catalogs/vendors`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication HTTPBearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            if (marketplaceId !== undefined) {
                localVarQueryParameter['marketplaceId'] = marketplaceId;
            }


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(vendorsByIdRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Get categories.
         * @summary Get Categories
         * @param {string} marketplaceId 
         * @param {number} [offset] 
         * @param {number} [limit] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getCategories: async (marketplaceId: string, offset?: number, limit?: number, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'marketplaceId' is not null or undefined
            assertParamExists('getCategories', 'marketplaceId', marketplaceId)
            const localVarPath = `/catalog-search-service/catalogs/categories`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication HTTPBearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            if (marketplaceId !== undefined) {
                localVarQueryParameter['marketplaceId'] = marketplaceId;
            }

            if (offset !== undefined) {
                localVarQueryParameter['offset'] = offset;
            }

            if (limit !== undefined) {
                localVarQueryParameter['limit'] = limit;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Get Configuration
         * @param {string} marketplaceId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getConfigurationCatalogSearchServiceConfigurationMarketplaceIdGet: async (marketplaceId: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'marketplaceId' is not null or undefined
            assertParamExists('getConfigurationCatalogSearchServiceConfigurationMarketplaceIdGet', 'marketplaceId', marketplaceId)
            const localVarPath = `/catalog-search-service/configuration/{marketplace_id}`
                .replace(`{${"marketplace_id"}}`, encodeURIComponent(String(marketplaceId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication HTTPBearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Get products by ID.
         * @summary Get Products
         * @param {Array<string>} id 
         * @param {string} marketplaceId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getProducts: async (id: Array<string>, marketplaceId: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('getProducts', 'id', id)
            // verify required parameter 'marketplaceId' is not null or undefined
            assertParamExists('getProducts', 'marketplaceId', marketplaceId)
            const localVarPath = `/catalog-search-service/catalogs/products`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication HTTPBearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            if (id) {
                localVarQueryParameter['id'] = id;
            }

            if (marketplaceId !== undefined) {
                localVarQueryParameter['marketplaceId'] = marketplaceId;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Get vendors.
         * @summary Get Vendors
         * @param {string} marketplaceId 
         * @param {number} [offset] 
         * @param {number} [limit] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getVendors: async (marketplaceId: string, offset?: number, limit?: number, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'marketplaceId' is not null or undefined
            assertParamExists('getVendors', 'marketplaceId', marketplaceId)
            const localVarPath = `/catalog-search-service/catalogs/vendors`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication HTTPBearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            if (marketplaceId !== undefined) {
                localVarQueryParameter['marketplaceId'] = marketplaceId;
            }

            if (offset !== undefined) {
                localVarQueryParameter['offset'] = offset;
            }

            if (limit !== undefined) {
                localVarQueryParameter['limit'] = limit;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Migrate Indices
         * @param {string} marketplaceId 
         * @param {string} [indexName] 
         * @param {string} [suffix] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        migrateIndicesCatalogSearchServiceConfigurationMigrateIndicesMarketplaceIdPost: async (marketplaceId: string, indexName?: string, suffix?: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'marketplaceId' is not null or undefined
            assertParamExists('migrateIndicesCatalogSearchServiceConfigurationMigrateIndicesMarketplaceIdPost', 'marketplaceId', marketplaceId)
            const localVarPath = `/catalog-search-service/configuration/migrate-indices/{marketplace_id}`
                .replace(`{${"marketplace_id"}}`, encodeURIComponent(String(marketplaceId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication HTTPBearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            if (indexName !== undefined) {
                localVarQueryParameter['index_name'] = indexName;
            }

            if (suffix !== undefined) {
                localVarQueryParameter['suffix'] = suffix;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * For each pull configuration, retrieves the catalog and updates the index
         * @summary Retrieve All
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        retrieveAllCatalogSearchServiceTriggersRunCatalogV1RetrieverAllPost: async (options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/catalog-search-service/triggers/run-catalog-v1-retriever/all`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication HTTPBearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Retrieve For Marketplace
         * @param {string} marketplaceId 
         * @param {number} [marketplaceLegacyId] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        retrieveForMarketplaceCatalogSearchServiceTriggersRunCatalogV1RetrieverMarketplaceMarketplaceIdPost: async (marketplaceId: string, marketplaceLegacyId?: number, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'marketplaceId' is not null or undefined
            assertParamExists('retrieveForMarketplaceCatalogSearchServiceTriggersRunCatalogV1RetrieverMarketplaceMarketplaceIdPost', 'marketplaceId', marketplaceId)
            const localVarPath = `/catalog-search-service/triggers/run-catalog-v1-retriever/marketplace/{marketplace_id}`
                .replace(`{${"marketplace_id"}}`, encodeURIComponent(String(marketplaceId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication HTTPBearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            if (marketplaceLegacyId !== undefined) {
                localVarQueryParameter['marketplace_legacy_id'] = marketplaceLegacyId;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Search products
         * @summary Search Products
         * @param {string} search 
         * @param {string} marketplaceId 
         * @param {string} [vendorId] 
         * @param {string} [categoryId] 
         * @param {number} [offset] 
         * @param {number} [limit] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        searchProducts: async (search: string, marketplaceId: string, vendorId?: string, categoryId?: string, offset?: number, limit?: number, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'search' is not null or undefined
            assertParamExists('searchProducts', 'search', search)
            // verify required parameter 'marketplaceId' is not null or undefined
            assertParamExists('searchProducts', 'marketplaceId', marketplaceId)
            const localVarPath = `/catalog-search-service/catalogs/products/search`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication HTTPBearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            if (search !== undefined) {
                localVarQueryParameter['search'] = search;
            }

            if (marketplaceId !== undefined) {
                localVarQueryParameter['marketplaceId'] = marketplaceId;
            }

            if (vendorId !== undefined) {
                localVarQueryParameter['vendorId'] = vendorId;
            }

            if (categoryId !== undefined) {
                localVarQueryParameter['categoryId'] = categoryId;
            }

            if (offset !== undefined) {
                localVarQueryParameter['offset'] = offset;
            }

            if (limit !== undefined) {
                localVarQueryParameter['limit'] = limit;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Update Configuration
         * @param {string} marketplaceId 
         * @param {PartialConfiguration} partialConfiguration 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateConfigurationCatalogSearchServiceConfigurationMarketplaceIdPatch: async (marketplaceId: string, partialConfiguration: PartialConfiguration, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'marketplaceId' is not null or undefined
            assertParamExists('updateConfigurationCatalogSearchServiceConfigurationMarketplaceIdPatch', 'marketplaceId', marketplaceId)
            // verify required parameter 'partialConfiguration' is not null or undefined
            assertParamExists('updateConfigurationCatalogSearchServiceConfigurationMarketplaceIdPatch', 'partialConfiguration', partialConfiguration)
            const localVarPath = `/catalog-search-service/configuration/{marketplace_id}`
                .replace(`{${"marketplace_id"}}`, encodeURIComponent(String(marketplaceId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PATCH', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication HTTPBearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(partialConfiguration, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Upload Categories File
         * @param {string} marketplaceId 
         * @param {any} file 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        uploadCategoriesFileCatalogSearchServiceUploadMarketplaceIdCategoriesPost: async (marketplaceId: string, file: any, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'marketplaceId' is not null or undefined
            assertParamExists('uploadCategoriesFileCatalogSearchServiceUploadMarketplaceIdCategoriesPost', 'marketplaceId', marketplaceId)
            // verify required parameter 'file' is not null or undefined
            assertParamExists('uploadCategoriesFileCatalogSearchServiceUploadMarketplaceIdCategoriesPost', 'file', file)
            const localVarPath = `/catalog-search-service/upload/{marketplace_id}/categories`
                .replace(`{${"marketplace_id"}}`, encodeURIComponent(String(marketplaceId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;
            const localVarFormParams = new ((configuration && configuration.formDataCtor) || FormData)();

            // authentication HTTPBearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


            if (file !== undefined) { 
                localVarFormParams.append('file', file as any);
            }
    
    
            localVarHeaderParameter['Content-Type'] = 'multipart/form-data';
    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = localVarFormParams;

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Upload Products File
         * @param {string} marketplaceId 
         * @param {any} file 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        uploadProductsFileCatalogSearchServiceUploadMarketplaceIdProductsPost: async (marketplaceId: string, file: any, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'marketplaceId' is not null or undefined
            assertParamExists('uploadProductsFileCatalogSearchServiceUploadMarketplaceIdProductsPost', 'marketplaceId', marketplaceId)
            // verify required parameter 'file' is not null or undefined
            assertParamExists('uploadProductsFileCatalogSearchServiceUploadMarketplaceIdProductsPost', 'file', file)
            const localVarPath = `/catalog-search-service/upload/{marketplace_id}/products`
                .replace(`{${"marketplace_id"}}`, encodeURIComponent(String(marketplaceId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;
            const localVarFormParams = new ((configuration && configuration.formDataCtor) || FormData)();

            // authentication HTTPBearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


            if (file !== undefined) { 
                localVarFormParams.append('file', file as any);
            }
    
    
            localVarHeaderParameter['Content-Type'] = 'multipart/form-data';
    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = localVarFormParams;

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Upload Vendors File
         * @param {string} marketplaceId 
         * @param {any} file 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        uploadVendorsFileCatalogSearchServiceUploadMarketplaceIdVendorsPost: async (marketplaceId: string, file: any, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'marketplaceId' is not null or undefined
            assertParamExists('uploadVendorsFileCatalogSearchServiceUploadMarketplaceIdVendorsPost', 'marketplaceId', marketplaceId)
            // verify required parameter 'file' is not null or undefined
            assertParamExists('uploadVendorsFileCatalogSearchServiceUploadMarketplaceIdVendorsPost', 'file', file)
            const localVarPath = `/catalog-search-service/upload/{marketplace_id}/vendors`
                .replace(`{${"marketplace_id"}}`, encodeURIComponent(String(marketplaceId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;
            const localVarFormParams = new ((configuration && configuration.formDataCtor) || FormData)();

            // authentication HTTPBearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


            if (file !== undefined) { 
                localVarFormParams.append('file', file as any);
            }
    
    
            localVarHeaderParameter['Content-Type'] = 'multipart/form-data';
    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = localVarFormParams;

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Upsert categories.
         * @summary Upsert Categories
         * @param {string} marketplaceId 
         * @param {CategoriesRequest} categoriesRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        upsertCategories: async (marketplaceId: string, categoriesRequest: CategoriesRequest, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'marketplaceId' is not null or undefined
            assertParamExists('upsertCategories', 'marketplaceId', marketplaceId)
            // verify required parameter 'categoriesRequest' is not null or undefined
            assertParamExists('upsertCategories', 'categoriesRequest', categoriesRequest)
            const localVarPath = `/catalog-search-service/catalogs/categories`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication HTTPBearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            if (marketplaceId !== undefined) {
                localVarQueryParameter['marketplaceId'] = marketplaceId;
            }


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(categoriesRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Upsert products.
         * @summary Upsert Products
         * @param {string} marketplaceId 
         * @param {ProductsRequest} productsRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        upsertProducts: async (marketplaceId: string, productsRequest: ProductsRequest, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'marketplaceId' is not null or undefined
            assertParamExists('upsertProducts', 'marketplaceId', marketplaceId)
            // verify required parameter 'productsRequest' is not null or undefined
            assertParamExists('upsertProducts', 'productsRequest', productsRequest)
            const localVarPath = `/catalog-search-service/catalogs/products`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication HTTPBearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            if (marketplaceId !== undefined) {
                localVarQueryParameter['marketplaceId'] = marketplaceId;
            }


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(productsRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Upsert vendors.
         * @summary Upsert Vendors
         * @param {string} marketplaceId 
         * @param {VendorsRequest} vendorsRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        upsertVendors: async (marketplaceId: string, vendorsRequest: VendorsRequest, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'marketplaceId' is not null or undefined
            assertParamExists('upsertVendors', 'marketplaceId', marketplaceId)
            // verify required parameter 'vendorsRequest' is not null or undefined
            assertParamExists('upsertVendors', 'vendorsRequest', vendorsRequest)
            const localVarPath = `/catalog-search-service/catalogs/vendors`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication HTTPBearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            if (marketplaceId !== undefined) {
                localVarQueryParameter['marketplaceId'] = marketplaceId;
            }


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(vendorsRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * CatalogSearchServiceApi - functional programming interface
 * @export
 */
export const CatalogSearchServiceApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = CatalogSearchServiceApiAxiosParamCreator(configuration)
    return {
        /**
         * 
         * @summary Create Configuration
         * @param {string} marketplaceId 
         * @param {PartialConfiguration} partialConfiguration 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async createConfigurationCatalogSearchServiceConfigurationMarketplaceIdPost(marketplaceId: string, partialConfiguration: PartialConfiguration, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<CatalogConfiguration>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.createConfigurationCatalogSearchServiceConfigurationMarketplaceIdPost(marketplaceId, partialConfiguration, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Create Indices
         * @param {string} marketplaceId 
         * @param {string} [suffix] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async createIndicesCatalogSearchServiceConfigurationIndicesMarketplaceIdPost(marketplaceId: string, suffix?: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<any>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.createIndicesCatalogSearchServiceConfigurationIndicesMarketplaceIdPost(marketplaceId, suffix, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Delete categories by ID.
         * @summary Delete Categories
         * @param {string} marketplaceId 
         * @param {CategoriesByIdRequest} categoriesByIdRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async deleteCategories(marketplaceId: string, categoriesByIdRequest: CategoriesByIdRequest, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.deleteCategories(marketplaceId, categoriesByIdRequest, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Delete Configuration
         * @param {string} marketplaceId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async deleteConfigurationCatalogSearchServiceConfigurationMarketplaceIdDelete(marketplaceId: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<any>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.deleteConfigurationCatalogSearchServiceConfigurationMarketplaceIdDelete(marketplaceId, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Delete Indices
         * @param {string} marketplaceId 
         * @param {string} [suffix] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async deleteIndicesCatalogSearchServiceConfigurationIndicesMarketplaceIdDelete(marketplaceId: string, suffix?: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<any>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.deleteIndicesCatalogSearchServiceConfigurationIndicesMarketplaceIdDelete(marketplaceId, suffix, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Delete products by ID.
         * @summary Delete Products
         * @param {string} marketplaceId 
         * @param {ProductsByIdRequest} productsByIdRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async deleteProducts(marketplaceId: string, productsByIdRequest: ProductsByIdRequest, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.deleteProducts(marketplaceId, productsByIdRequest, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Delete vendors by ID.
         * @summary Delete Vendors
         * @param {string} marketplaceId 
         * @param {VendorsByIdRequest} vendorsByIdRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async deleteVendors(marketplaceId: string, vendorsByIdRequest: VendorsByIdRequest, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.deleteVendors(marketplaceId, vendorsByIdRequest, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Get categories.
         * @summary Get Categories
         * @param {string} marketplaceId 
         * @param {number} [offset] 
         * @param {number} [limit] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getCategories(marketplaceId: string, offset?: number, limit?: number, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<CategoriesResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getCategories(marketplaceId, offset, limit, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Get Configuration
         * @param {string} marketplaceId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getConfigurationCatalogSearchServiceConfigurationMarketplaceIdGet(marketplaceId: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<CatalogConfiguration>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getConfigurationCatalogSearchServiceConfigurationMarketplaceIdGet(marketplaceId, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Get products by ID.
         * @summary Get Products
         * @param {Array<string>} id 
         * @param {string} marketplaceId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getProducts(id: Array<string>, marketplaceId: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<Product>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getProducts(id, marketplaceId, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Get vendors.
         * @summary Get Vendors
         * @param {string} marketplaceId 
         * @param {number} [offset] 
         * @param {number} [limit] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getVendors(marketplaceId: string, offset?: number, limit?: number, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<VendorsResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getVendors(marketplaceId, offset, limit, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Migrate Indices
         * @param {string} marketplaceId 
         * @param {string} [indexName] 
         * @param {string} [suffix] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async migrateIndicesCatalogSearchServiceConfigurationMigrateIndicesMarketplaceIdPost(marketplaceId: string, indexName?: string, suffix?: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<any>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.migrateIndicesCatalogSearchServiceConfigurationMigrateIndicesMarketplaceIdPost(marketplaceId, indexName, suffix, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * For each pull configuration, retrieves the catalog and updates the index
         * @summary Retrieve All
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async retrieveAllCatalogSearchServiceTriggersRunCatalogV1RetrieverAllPost(options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<any>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.retrieveAllCatalogSearchServiceTriggersRunCatalogV1RetrieverAllPost(options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Retrieve For Marketplace
         * @param {string} marketplaceId 
         * @param {number} [marketplaceLegacyId] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async retrieveForMarketplaceCatalogSearchServiceTriggersRunCatalogV1RetrieverMarketplaceMarketplaceIdPost(marketplaceId: string, marketplaceLegacyId?: number, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<any>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.retrieveForMarketplaceCatalogSearchServiceTriggersRunCatalogV1RetrieverMarketplaceMarketplaceIdPost(marketplaceId, marketplaceLegacyId, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Search products
         * @summary Search Products
         * @param {string} search 
         * @param {string} marketplaceId 
         * @param {string} [vendorId] 
         * @param {string} [categoryId] 
         * @param {number} [offset] 
         * @param {number} [limit] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async searchProducts(search: string, marketplaceId: string, vendorId?: string, categoryId?: string, offset?: number, limit?: number, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ProductsResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.searchProducts(search, marketplaceId, vendorId, categoryId, offset, limit, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Update Configuration
         * @param {string} marketplaceId 
         * @param {PartialConfiguration} partialConfiguration 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async updateConfigurationCatalogSearchServiceConfigurationMarketplaceIdPatch(marketplaceId: string, partialConfiguration: PartialConfiguration, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<CatalogConfiguration>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.updateConfigurationCatalogSearchServiceConfigurationMarketplaceIdPatch(marketplaceId, partialConfiguration, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Upload Categories File
         * @param {string} marketplaceId 
         * @param {any} file 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async uploadCategoriesFileCatalogSearchServiceUploadMarketplaceIdCategoriesPost(marketplaceId: string, file: any, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<any>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.uploadCategoriesFileCatalogSearchServiceUploadMarketplaceIdCategoriesPost(marketplaceId, file, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Upload Products File
         * @param {string} marketplaceId 
         * @param {any} file 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async uploadProductsFileCatalogSearchServiceUploadMarketplaceIdProductsPost(marketplaceId: string, file: any, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<any>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.uploadProductsFileCatalogSearchServiceUploadMarketplaceIdProductsPost(marketplaceId, file, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Upload Vendors File
         * @param {string} marketplaceId 
         * @param {any} file 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async uploadVendorsFileCatalogSearchServiceUploadMarketplaceIdVendorsPost(marketplaceId: string, file: any, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<any>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.uploadVendorsFileCatalogSearchServiceUploadMarketplaceIdVendorsPost(marketplaceId, file, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Upsert categories.
         * @summary Upsert Categories
         * @param {string} marketplaceId 
         * @param {CategoriesRequest} categoriesRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async upsertCategories(marketplaceId: string, categoriesRequest: CategoriesRequest, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.upsertCategories(marketplaceId, categoriesRequest, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Upsert products.
         * @summary Upsert Products
         * @param {string} marketplaceId 
         * @param {ProductsRequest} productsRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async upsertProducts(marketplaceId: string, productsRequest: ProductsRequest, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.upsertProducts(marketplaceId, productsRequest, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Upsert vendors.
         * @summary Upsert Vendors
         * @param {string} marketplaceId 
         * @param {VendorsRequest} vendorsRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async upsertVendors(marketplaceId: string, vendorsRequest: VendorsRequest, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.upsertVendors(marketplaceId, vendorsRequest, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
    }
};

/**
 * CatalogSearchServiceApi - factory interface
 * @export
 */
export const CatalogSearchServiceApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = CatalogSearchServiceApiFp(configuration)
    return {
        /**
         * 
         * @summary Create Configuration
         * @param {string} marketplaceId 
         * @param {PartialConfiguration} partialConfiguration 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createConfigurationCatalogSearchServiceConfigurationMarketplaceIdPost(marketplaceId: string, partialConfiguration: PartialConfiguration, options?: any): AxiosPromise<CatalogConfiguration> {
            return localVarFp.createConfigurationCatalogSearchServiceConfigurationMarketplaceIdPost(marketplaceId, partialConfiguration, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Create Indices
         * @param {string} marketplaceId 
         * @param {string} [suffix] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createIndicesCatalogSearchServiceConfigurationIndicesMarketplaceIdPost(marketplaceId: string, suffix?: string, options?: any): AxiosPromise<any> {
            return localVarFp.createIndicesCatalogSearchServiceConfigurationIndicesMarketplaceIdPost(marketplaceId, suffix, options).then((request) => request(axios, basePath));
        },
        /**
         * Delete categories by ID.
         * @summary Delete Categories
         * @param {string} marketplaceId 
         * @param {CategoriesByIdRequest} categoriesByIdRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteCategories(marketplaceId: string, categoriesByIdRequest: CategoriesByIdRequest, options?: any): AxiosPromise<void> {
            return localVarFp.deleteCategories(marketplaceId, categoriesByIdRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Delete Configuration
         * @param {string} marketplaceId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteConfigurationCatalogSearchServiceConfigurationMarketplaceIdDelete(marketplaceId: string, options?: any): AxiosPromise<any> {
            return localVarFp.deleteConfigurationCatalogSearchServiceConfigurationMarketplaceIdDelete(marketplaceId, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Delete Indices
         * @param {string} marketplaceId 
         * @param {string} [suffix] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteIndicesCatalogSearchServiceConfigurationIndicesMarketplaceIdDelete(marketplaceId: string, suffix?: string, options?: any): AxiosPromise<any> {
            return localVarFp.deleteIndicesCatalogSearchServiceConfigurationIndicesMarketplaceIdDelete(marketplaceId, suffix, options).then((request) => request(axios, basePath));
        },
        /**
         * Delete products by ID.
         * @summary Delete Products
         * @param {string} marketplaceId 
         * @param {ProductsByIdRequest} productsByIdRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteProducts(marketplaceId: string, productsByIdRequest: ProductsByIdRequest, options?: any): AxiosPromise<void> {
            return localVarFp.deleteProducts(marketplaceId, productsByIdRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * Delete vendors by ID.
         * @summary Delete Vendors
         * @param {string} marketplaceId 
         * @param {VendorsByIdRequest} vendorsByIdRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteVendors(marketplaceId: string, vendorsByIdRequest: VendorsByIdRequest, options?: any): AxiosPromise<void> {
            return localVarFp.deleteVendors(marketplaceId, vendorsByIdRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * Get categories.
         * @summary Get Categories
         * @param {string} marketplaceId 
         * @param {number} [offset] 
         * @param {number} [limit] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getCategories(marketplaceId: string, offset?: number, limit?: number, options?: any): AxiosPromise<CategoriesResponse> {
            return localVarFp.getCategories(marketplaceId, offset, limit, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Get Configuration
         * @param {string} marketplaceId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getConfigurationCatalogSearchServiceConfigurationMarketplaceIdGet(marketplaceId: string, options?: any): AxiosPromise<CatalogConfiguration> {
            return localVarFp.getConfigurationCatalogSearchServiceConfigurationMarketplaceIdGet(marketplaceId, options).then((request) => request(axios, basePath));
        },
        /**
         * Get products by ID.
         * @summary Get Products
         * @param {Array<string>} id 
         * @param {string} marketplaceId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getProducts(id: Array<string>, marketplaceId: string, options?: any): AxiosPromise<Array<Product>> {
            return localVarFp.getProducts(id, marketplaceId, options).then((request) => request(axios, basePath));
        },
        /**
         * Get vendors.
         * @summary Get Vendors
         * @param {string} marketplaceId 
         * @param {number} [offset] 
         * @param {number} [limit] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getVendors(marketplaceId: string, offset?: number, limit?: number, options?: any): AxiosPromise<VendorsResponse> {
            return localVarFp.getVendors(marketplaceId, offset, limit, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Migrate Indices
         * @param {string} marketplaceId 
         * @param {string} [indexName] 
         * @param {string} [suffix] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        migrateIndicesCatalogSearchServiceConfigurationMigrateIndicesMarketplaceIdPost(marketplaceId: string, indexName?: string, suffix?: string, options?: any): AxiosPromise<any> {
            return localVarFp.migrateIndicesCatalogSearchServiceConfigurationMigrateIndicesMarketplaceIdPost(marketplaceId, indexName, suffix, options).then((request) => request(axios, basePath));
        },
        /**
         * For each pull configuration, retrieves the catalog and updates the index
         * @summary Retrieve All
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        retrieveAllCatalogSearchServiceTriggersRunCatalogV1RetrieverAllPost(options?: any): AxiosPromise<any> {
            return localVarFp.retrieveAllCatalogSearchServiceTriggersRunCatalogV1RetrieverAllPost(options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Retrieve For Marketplace
         * @param {string} marketplaceId 
         * @param {number} [marketplaceLegacyId] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        retrieveForMarketplaceCatalogSearchServiceTriggersRunCatalogV1RetrieverMarketplaceMarketplaceIdPost(marketplaceId: string, marketplaceLegacyId?: number, options?: any): AxiosPromise<any> {
            return localVarFp.retrieveForMarketplaceCatalogSearchServiceTriggersRunCatalogV1RetrieverMarketplaceMarketplaceIdPost(marketplaceId, marketplaceLegacyId, options).then((request) => request(axios, basePath));
        },
        /**
         * Search products
         * @summary Search Products
         * @param {string} search 
         * @param {string} marketplaceId 
         * @param {string} [vendorId] 
         * @param {string} [categoryId] 
         * @param {number} [offset] 
         * @param {number} [limit] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        searchProducts(search: string, marketplaceId: string, vendorId?: string, categoryId?: string, offset?: number, limit?: number, options?: any): AxiosPromise<ProductsResponse> {
            return localVarFp.searchProducts(search, marketplaceId, vendorId, categoryId, offset, limit, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Update Configuration
         * @param {string} marketplaceId 
         * @param {PartialConfiguration} partialConfiguration 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateConfigurationCatalogSearchServiceConfigurationMarketplaceIdPatch(marketplaceId: string, partialConfiguration: PartialConfiguration, options?: any): AxiosPromise<CatalogConfiguration> {
            return localVarFp.updateConfigurationCatalogSearchServiceConfigurationMarketplaceIdPatch(marketplaceId, partialConfiguration, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Upload Categories File
         * @param {string} marketplaceId 
         * @param {any} file 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        uploadCategoriesFileCatalogSearchServiceUploadMarketplaceIdCategoriesPost(marketplaceId: string, file: any, options?: any): AxiosPromise<any> {
            return localVarFp.uploadCategoriesFileCatalogSearchServiceUploadMarketplaceIdCategoriesPost(marketplaceId, file, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Upload Products File
         * @param {string} marketplaceId 
         * @param {any} file 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        uploadProductsFileCatalogSearchServiceUploadMarketplaceIdProductsPost(marketplaceId: string, file: any, options?: any): AxiosPromise<any> {
            return localVarFp.uploadProductsFileCatalogSearchServiceUploadMarketplaceIdProductsPost(marketplaceId, file, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Upload Vendors File
         * @param {string} marketplaceId 
         * @param {any} file 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        uploadVendorsFileCatalogSearchServiceUploadMarketplaceIdVendorsPost(marketplaceId: string, file: any, options?: any): AxiosPromise<any> {
            return localVarFp.uploadVendorsFileCatalogSearchServiceUploadMarketplaceIdVendorsPost(marketplaceId, file, options).then((request) => request(axios, basePath));
        },
        /**
         * Upsert categories.
         * @summary Upsert Categories
         * @param {string} marketplaceId 
         * @param {CategoriesRequest} categoriesRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        upsertCategories(marketplaceId: string, categoriesRequest: CategoriesRequest, options?: any): AxiosPromise<void> {
            return localVarFp.upsertCategories(marketplaceId, categoriesRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * Upsert products.
         * @summary Upsert Products
         * @param {string} marketplaceId 
         * @param {ProductsRequest} productsRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        upsertProducts(marketplaceId: string, productsRequest: ProductsRequest, options?: any): AxiosPromise<void> {
            return localVarFp.upsertProducts(marketplaceId, productsRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * Upsert vendors.
         * @summary Upsert Vendors
         * @param {string} marketplaceId 
         * @param {VendorsRequest} vendorsRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        upsertVendors(marketplaceId: string, vendorsRequest: VendorsRequest, options?: any): AxiosPromise<void> {
            return localVarFp.upsertVendors(marketplaceId, vendorsRequest, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * CatalogSearchServiceApi - object-oriented interface
 * @export
 * @class CatalogSearchServiceApi
 * @extends {BaseAPI}
 */
export class CatalogSearchServiceApi extends BaseAPI {
    /**
     * 
     * @summary Create Configuration
     * @param {string} marketplaceId 
     * @param {PartialConfiguration} partialConfiguration 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof CatalogSearchServiceApi
     */
    public createConfigurationCatalogSearchServiceConfigurationMarketplaceIdPost(marketplaceId: string, partialConfiguration: PartialConfiguration, options?: AxiosRequestConfig) {
        return CatalogSearchServiceApiFp(this.configuration).createConfigurationCatalogSearchServiceConfigurationMarketplaceIdPost(marketplaceId, partialConfiguration, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Create Indices
     * @param {string} marketplaceId 
     * @param {string} [suffix] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof CatalogSearchServiceApi
     */
    public createIndicesCatalogSearchServiceConfigurationIndicesMarketplaceIdPost(marketplaceId: string, suffix?: string, options?: AxiosRequestConfig) {
        return CatalogSearchServiceApiFp(this.configuration).createIndicesCatalogSearchServiceConfigurationIndicesMarketplaceIdPost(marketplaceId, suffix, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Delete categories by ID.
     * @summary Delete Categories
     * @param {string} marketplaceId 
     * @param {CategoriesByIdRequest} categoriesByIdRequest 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof CatalogSearchServiceApi
     */
    public deleteCategories(marketplaceId: string, categoriesByIdRequest: CategoriesByIdRequest, options?: AxiosRequestConfig) {
        return CatalogSearchServiceApiFp(this.configuration).deleteCategories(marketplaceId, categoriesByIdRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Delete Configuration
     * @param {string} marketplaceId 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof CatalogSearchServiceApi
     */
    public deleteConfigurationCatalogSearchServiceConfigurationMarketplaceIdDelete(marketplaceId: string, options?: AxiosRequestConfig) {
        return CatalogSearchServiceApiFp(this.configuration).deleteConfigurationCatalogSearchServiceConfigurationMarketplaceIdDelete(marketplaceId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Delete Indices
     * @param {string} marketplaceId 
     * @param {string} [suffix] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof CatalogSearchServiceApi
     */
    public deleteIndicesCatalogSearchServiceConfigurationIndicesMarketplaceIdDelete(marketplaceId: string, suffix?: string, options?: AxiosRequestConfig) {
        return CatalogSearchServiceApiFp(this.configuration).deleteIndicesCatalogSearchServiceConfigurationIndicesMarketplaceIdDelete(marketplaceId, suffix, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Delete products by ID.
     * @summary Delete Products
     * @param {string} marketplaceId 
     * @param {ProductsByIdRequest} productsByIdRequest 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof CatalogSearchServiceApi
     */
    public deleteProducts(marketplaceId: string, productsByIdRequest: ProductsByIdRequest, options?: AxiosRequestConfig) {
        return CatalogSearchServiceApiFp(this.configuration).deleteProducts(marketplaceId, productsByIdRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Delete vendors by ID.
     * @summary Delete Vendors
     * @param {string} marketplaceId 
     * @param {VendorsByIdRequest} vendorsByIdRequest 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof CatalogSearchServiceApi
     */
    public deleteVendors(marketplaceId: string, vendorsByIdRequest: VendorsByIdRequest, options?: AxiosRequestConfig) {
        return CatalogSearchServiceApiFp(this.configuration).deleteVendors(marketplaceId, vendorsByIdRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Get categories.
     * @summary Get Categories
     * @param {string} marketplaceId 
     * @param {number} [offset] 
     * @param {number} [limit] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof CatalogSearchServiceApi
     */
    public getCategories(marketplaceId: string, offset?: number, limit?: number, options?: AxiosRequestConfig) {
        return CatalogSearchServiceApiFp(this.configuration).getCategories(marketplaceId, offset, limit, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Get Configuration
     * @param {string} marketplaceId 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof CatalogSearchServiceApi
     */
    public getConfigurationCatalogSearchServiceConfigurationMarketplaceIdGet(marketplaceId: string, options?: AxiosRequestConfig) {
        return CatalogSearchServiceApiFp(this.configuration).getConfigurationCatalogSearchServiceConfigurationMarketplaceIdGet(marketplaceId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Get products by ID.
     * @summary Get Products
     * @param {Array<string>} id 
     * @param {string} marketplaceId 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof CatalogSearchServiceApi
     */
    public getProducts(id: Array<string>, marketplaceId: string, options?: AxiosRequestConfig) {
        return CatalogSearchServiceApiFp(this.configuration).getProducts(id, marketplaceId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Get vendors.
     * @summary Get Vendors
     * @param {string} marketplaceId 
     * @param {number} [offset] 
     * @param {number} [limit] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof CatalogSearchServiceApi
     */
    public getVendors(marketplaceId: string, offset?: number, limit?: number, options?: AxiosRequestConfig) {
        return CatalogSearchServiceApiFp(this.configuration).getVendors(marketplaceId, offset, limit, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Migrate Indices
     * @param {string} marketplaceId 
     * @param {string} [indexName] 
     * @param {string} [suffix] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof CatalogSearchServiceApi
     */
    public migrateIndicesCatalogSearchServiceConfigurationMigrateIndicesMarketplaceIdPost(marketplaceId: string, indexName?: string, suffix?: string, options?: AxiosRequestConfig) {
        return CatalogSearchServiceApiFp(this.configuration).migrateIndicesCatalogSearchServiceConfigurationMigrateIndicesMarketplaceIdPost(marketplaceId, indexName, suffix, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * For each pull configuration, retrieves the catalog and updates the index
     * @summary Retrieve All
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof CatalogSearchServiceApi
     */
    public retrieveAllCatalogSearchServiceTriggersRunCatalogV1RetrieverAllPost(options?: AxiosRequestConfig) {
        return CatalogSearchServiceApiFp(this.configuration).retrieveAllCatalogSearchServiceTriggersRunCatalogV1RetrieverAllPost(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Retrieve For Marketplace
     * @param {string} marketplaceId 
     * @param {number} [marketplaceLegacyId] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof CatalogSearchServiceApi
     */
    public retrieveForMarketplaceCatalogSearchServiceTriggersRunCatalogV1RetrieverMarketplaceMarketplaceIdPost(marketplaceId: string, marketplaceLegacyId?: number, options?: AxiosRequestConfig) {
        return CatalogSearchServiceApiFp(this.configuration).retrieveForMarketplaceCatalogSearchServiceTriggersRunCatalogV1RetrieverMarketplaceMarketplaceIdPost(marketplaceId, marketplaceLegacyId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Search products
     * @summary Search Products
     * @param {string} search 
     * @param {string} marketplaceId 
     * @param {string} [vendorId] 
     * @param {string} [categoryId] 
     * @param {number} [offset] 
     * @param {number} [limit] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof CatalogSearchServiceApi
     */
    public searchProducts(search: string, marketplaceId: string, vendorId?: string, categoryId?: string, offset?: number, limit?: number, options?: AxiosRequestConfig) {
        return CatalogSearchServiceApiFp(this.configuration).searchProducts(search, marketplaceId, vendorId, categoryId, offset, limit, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Update Configuration
     * @param {string} marketplaceId 
     * @param {PartialConfiguration} partialConfiguration 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof CatalogSearchServiceApi
     */
    public updateConfigurationCatalogSearchServiceConfigurationMarketplaceIdPatch(marketplaceId: string, partialConfiguration: PartialConfiguration, options?: AxiosRequestConfig) {
        return CatalogSearchServiceApiFp(this.configuration).updateConfigurationCatalogSearchServiceConfigurationMarketplaceIdPatch(marketplaceId, partialConfiguration, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Upload Categories File
     * @param {string} marketplaceId 
     * @param {any} file 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof CatalogSearchServiceApi
     */
    public uploadCategoriesFileCatalogSearchServiceUploadMarketplaceIdCategoriesPost(marketplaceId: string, file: any, options?: AxiosRequestConfig) {
        return CatalogSearchServiceApiFp(this.configuration).uploadCategoriesFileCatalogSearchServiceUploadMarketplaceIdCategoriesPost(marketplaceId, file, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Upload Products File
     * @param {string} marketplaceId 
     * @param {any} file 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof CatalogSearchServiceApi
     */
    public uploadProductsFileCatalogSearchServiceUploadMarketplaceIdProductsPost(marketplaceId: string, file: any, options?: AxiosRequestConfig) {
        return CatalogSearchServiceApiFp(this.configuration).uploadProductsFileCatalogSearchServiceUploadMarketplaceIdProductsPost(marketplaceId, file, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Upload Vendors File
     * @param {string} marketplaceId 
     * @param {any} file 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof CatalogSearchServiceApi
     */
    public uploadVendorsFileCatalogSearchServiceUploadMarketplaceIdVendorsPost(marketplaceId: string, file: any, options?: AxiosRequestConfig) {
        return CatalogSearchServiceApiFp(this.configuration).uploadVendorsFileCatalogSearchServiceUploadMarketplaceIdVendorsPost(marketplaceId, file, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Upsert categories.
     * @summary Upsert Categories
     * @param {string} marketplaceId 
     * @param {CategoriesRequest} categoriesRequest 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof CatalogSearchServiceApi
     */
    public upsertCategories(marketplaceId: string, categoriesRequest: CategoriesRequest, options?: AxiosRequestConfig) {
        return CatalogSearchServiceApiFp(this.configuration).upsertCategories(marketplaceId, categoriesRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Upsert products.
     * @summary Upsert Products
     * @param {string} marketplaceId 
     * @param {ProductsRequest} productsRequest 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof CatalogSearchServiceApi
     */
    public upsertProducts(marketplaceId: string, productsRequest: ProductsRequest, options?: AxiosRequestConfig) {
        return CatalogSearchServiceApiFp(this.configuration).upsertProducts(marketplaceId, productsRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Upsert vendors.
     * @summary Upsert Vendors
     * @param {string} marketplaceId 
     * @param {VendorsRequest} vendorsRequest 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof CatalogSearchServiceApi
     */
    public upsertVendors(marketplaceId: string, vendorsRequest: VendorsRequest, options?: AxiosRequestConfig) {
        return CatalogSearchServiceApiFp(this.configuration).upsertVendors(marketplaceId, vendorsRequest, options).then((request) => request(this.axios, this.basePath));
    }
}
